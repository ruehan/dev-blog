---
title: "React Native Connectivity"
date: "2025-01-15"
excerpt: "React Native Connectivity"
tags: ["React Native"]
category: "개발"
---

# 네트워킹

많은 모바일 앱은 원격 URL에서 리소스를 로드해야 해요. REST API에 POST 요청을 하거나, 다른 서버에서 정적 콘텐츠를 가져와야 할 수 있죠.

## Fetch 사용하기

React Native는 네트워킹 요구사항을 위해 Fetch API를 제공해요. XMLHttpRequest나 다른 네트워킹 API를 사용해봤다면 Fetch가 익숙할 거예요. 추가 정보는 MDN의 Fetch 사용 가이드를 참고하세요.

### 요청하기

임의의 URL에서 콘텐츠를 가져오려면 URL을 fetch에 전달하면 돼요:

```tsx
fetch('https://mywebsite.com/mydata.json');
```

Fetch는 HTTP 요청을 커스터마이즈할 수 있는 선택적 두 번째 인자도 받아요. 추가 헤더를 지정하거나 POST 요청을 만들고 싶을 수 있죠:

```tsx
fetch('https://mywebsite.com/endpoint/', {
  method: 'POST',
  headers: {
    Accept: 'application/json',
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    firstParam: 'yourValue',
    secondParam: 'yourOtherValue',
  }),
});
```

전체 속성 목록은 Fetch Request 문서를 참고하세요.

### 응답 처리하기

위의 예시들은 요청을 보내는 방법을 보여줘요. 대부분의 경우, 응답으로 뭔가를 하고 싶을 거예요.

네트워킹은 본질적으로 비동기 작업이에요. Fetch 메서드는 비동기 방식으로 작동하는 코드를 작성하기 쉽게 해주는 Promise를 반환해요:

```tsx
const getMoviesFromApi = () => {
  return fetch('https://reactnative.dev/movies.json')
    .then(response => response.json())
    .then(json => {
      return json.movies;
    })
    .catch(error => {
      console.error(error);
    });
};
```

React Native 앱에서는 <code>async</code>/<code>await</code> 구문도 사용할 수 있어요:

```tsx
const getMoviesFromApiAsync = async () => {
  try {
    const response = await fetch(
      'https://reactnative.dev/movies.json',
    );
    const json = await response.json();
    return json.movies;
  } catch (error) {
    console.error(error);
  }
};
```

<code>fetch</code>에서 발생할 수 있는 오류를 반드시 catch하세요. 그렇지 않으면 오류가 조용히 무시될 거예요.

### Fetch 예시

<iframe
	src="https://snack.expo.dev/embedded/x1SJVzen3t7o3hsdgZujj"
	style={{
		width: "100%",
		height: "500px",
		border: "1px solid #ddd",
		borderRadius: "4px",
		overflow: "hidden",
	}}
/>

기본적으로 iOS 9.0 이상에서는 App Transport Security(ATS)를 적용해요. ATS는 모든 HTTP 연결에 HTTPS 사용을 요구해요. 일반 텍스트 URL(<code>http</code>로 시작하는)에서 fetch하려면 먼저 ATS 예외를 추가해야 해요. 접근해야 할 도메인을 미리 알고 있다면, 해당 도메인에 대한 예외를 추가하는 것이 더 안전해요. 런타임 전까지 도메인을 알 수 없는 경우에는 ATS를 완전히 비활성화할 수 있어요. 하지만 2017년 1월부터 Apple의 App Store 검토에서는 ATS 비활성화에 대한 합당한 이유가 필요하다는 점에 유의하세요. 자세한 내용은 Apple의 문서를 참고하세요.

Android에서는 API 레벨 28부터 일반 텍스트 트래픽도 기본적으로 차단돼요. 이 동작은 앱 매니페스트 파일에서 <code>android:usesCleartextTraffic</code>을 설정해서 재정의할 수 있어요.

## 다른 네트워킹 라이브러리 사용하기

XMLHttpRequest API는 React Native에 내장되어 있어요. 이는 [frisbee](https://github.com/ladjs/frisbee)나 [axios](https://github.com/axios/axios) 같은 이를 기반으로 하는 서드파티 라이브러리를 사용하거나, 원한다면 XMLHttpRequest API를 직접 사용할 수 있다는 의미예요.

```tsx
const request = new XMLHttpRequest();
request.onreadystatechange = e => {
  if (request.readyState !== 4) {
    return;
  }

  if (request.status === 200) {
    console.log('success', request.responseText);
  } else {
    console.warn('error');
  }
};

request.open('GET', 'https://mywebsite.com/endpoint/');
request.send();
```

XMLHttpRequest의 보안 모델은 웹과 다른데, 네이티브 앱에서는 CORS 개념이 없기 때문이에요.

## WebSocket 지원

React Native는 단일 TCP 연결을 통해 전이중 통신 채널을 제공하는 프로토콜인 WebSocket도 지원해요.

```tsx
const ws = new WebSocket('ws://host.com/path');

ws.onopen = () => {
  // connection opened
  ws.send('something'); // send a message
};

ws.onmessage = e => {
  // a message was received
  console.log(e.data);
};

ws.onerror = e => {
  // an error occurred
  console.log(e.message);
};

ws.onclose = e => {
  // connection closed
  console.log(e.code, e.reason);
};
```

## fetch와 쿠키 기반 인증의 알려진 문제점

다음 옵션들은 현재 <code>fetch</code>와 함께 작동하지 않아요:

* <code>redirect:manual</code>
* <code>credentials:omit</code>
* Android에서 같은 이름의 헤더가 있으면 가장 최근 것만 존재하게 돼요. 임시 해결책은 여기에서 찾을 수 있어요: https://github.com/facebook/react-native/issues/18837#issuecomment-398779994
* 쿠키 기반 인증은 현재 불안정해요. 관련 이슈들은 여기에서 확인할 수 있어요: https://github.com/facebook/react-native/issues/23185
* iOS에서는 최소한 <code>302</code> 리다이렉트를 통해 리다이렉트될 때, <code>Set-Cookie</code> 헤더가 있다면 쿠키가 제대로 설정되지 않아요. 리다이렉트를 수동으로 처리할 수 없기 때문에, 만료된 세션으로 인한 리다이렉트가 발생하면 무한 요청이 발생할 수 있어요.

## iOS에서 NSURLSession 구성하기

일부 애플리케이션에서는 iOS에서 실행되는 React Native 애플리케이션의 네트워크 요청에 사용되는 기본 <code>NSURLSession</code>에 대해 커스텀 <code>NSURLSessionConfiguration</code>을 제공하는 것이 적절할 수 있어요. 예를 들어, 앱에서 오는 모든 네트워크 요청에 대해 커스텀 사용자 에이전트 문자열을 설정하거나 임시 <code>NSURLSessionConfiguration</code>으로 <code>NSURLSession</code>을 제공해야 할 수 있어요. <code>RCTSetCustomNSURLSessionConfigurationProvider</code> 함수를 사용하면 이러한 커스터마이즈가 가능해요. <code>RCTSetCustomNSURLSessionConfigurationProvider</code>가 호출될 파일에 다음 import를 추가하는 것을 잊지 마세요:

```objective-c
#import <React/RCTHTTPRequestHandler.h>
```

<code>RCTSetCustomNSURLSessionConfigurationProvider</code>는 React가 필요로 할 때 즉시 사용할 수 있도록 애플리케이션 생명주기 초기에 호출되어야 해요. 예를 들면:

```objective-c
-(void)application:(__unused UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {

  // set RCTSetCustomNSURLSessionConfigurationProvider
  RCTSetCustomNSURLSessionConfigurationProvider(^NSURLSessionConfiguration *{
     NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
     // configure the session
     return configuration;
  });

  // set up React
  _bridge = [[RCTBridge alloc] initWithDelegate:self launchOptions:launchOptions];
}
```